/*
  # Fix All Point Farming Exploits
  
  1. New Tables
    - `follow_points_awarded` - Tracks which follows have been awarded points
    - `post_points_awarded` - Tracks which posts have been awarded points
  
  2. Changes
    - Prevent follow/unfollow/follow farming
    - Prevent post create/delete/create farming
    - Messages are already safe (content-based, can't be duplicated easily)
  
  3. Security
    - Enable RLS on new tables
    - Only system can insert via triggers
*/

-- Create table to track which follows have been awarded points
CREATE TABLE IF NOT EXISTS follow_points_awarded (
  follower_id uuid NOT NULL,
  followed_id uuid NOT NULL,
  awarded_at timestamptz DEFAULT now(),
  PRIMARY KEY (follower_id, followed_id)
);

-- Create table to track which posts have been awarded points
CREATE TABLE IF NOT EXISTS post_points_awarded (
  post_id uuid NOT NULL,
  awarded_at timestamptz DEFAULT now(),
  PRIMARY KEY (post_id)
);

-- Enable RLS
ALTER TABLE follow_points_awarded ENABLE ROW LEVEL SECURITY;
ALTER TABLE post_points_awarded ENABLE ROW LEVEL SECURITY;

-- No direct access policies
CREATE POLICY "No direct access to follow_points_awarded"
  ON follow_points_awarded FOR ALL
  TO authenticated
  USING (false);

CREATE POLICY "No direct access to post_points_awarded"
  ON post_points_awarded FOR ALL
  TO authenticated
  USING (false);

-- Update follow trigger to prevent farming
CREATE OR REPLACE FUNCTION award_points_on_follow()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_already_awarded boolean;
BEGIN
  -- Check if points were already awarded for this follow combo
  SELECT EXISTS (
    SELECT 1 FROM follow_points_awarded
    WHERE follower_id = NEW.follower_id AND followed_id = NEW.followed_id
  ) INTO v_already_awarded;
  
  -- Only award points if this is the first time EVER
  IF NOT v_already_awarded THEN
    PERFORM award_activity_points(NEW.follower_id, 5, 'follow_user');
    
    -- Mark that points have been awarded
    INSERT INTO follow_points_awarded (follower_id, followed_id)
    VALUES (NEW.follower_id, NEW.followed_id)
    ON CONFLICT (follower_id, followed_id) DO NOTHING;
  END IF;
  
  RETURN NEW;
END;
$$;

-- Update post creation trigger to prevent farming
CREATE OR REPLACE FUNCTION award_points_on_post()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_already_awarded boolean;
BEGIN
  -- Check if points were already awarded for this post
  SELECT EXISTS (
    SELECT 1 FROM post_points_awarded
    WHERE post_id = NEW.id
  ) INTO v_already_awarded;
  
  -- Only award points if this is the first time
  IF NOT v_already_awarded THEN
    PERFORM award_activity_points(NEW.user_id, 15, 'create_post');
    
    -- Mark that points have been awarded
    INSERT INTO post_points_awarded (post_id)
    VALUES (NEW.id)
    ON CONFLICT (post_id) DO NOTHING;
  END IF;
  
  RETURN NEW;
END;
$$;

-- Recreate triggers
DROP TRIGGER IF EXISTS trigger_award_points_on_follow ON follows;
CREATE TRIGGER trigger_award_points_on_follow
  AFTER INSERT ON follows
  FOR EACH ROW
  EXECUTE FUNCTION award_points_on_follow();

DROP TRIGGER IF EXISTS trigger_award_points_on_post ON feed_posts;
CREATE TRIGGER trigger_award_points_on_post
  AFTER INSERT ON feed_posts
  FOR EACH ROW
  EXECUTE FUNCTION award_points_on_post();

-- Populate existing data to prevent retroactive farming
INSERT INTO follow_points_awarded (follower_id, followed_id, awarded_at)
SELECT follower_id, followed_id, created_at
FROM follows
ON CONFLICT (follower_id, followed_id) DO NOTHING;

INSERT INTO post_points_awarded (post_id, awarded_at)
SELECT id, created_at
FROM feed_posts
ON CONFLICT (post_id) DO NOTHING;
